<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0056)http://athena.nitc.ac.in/kmurali/Compiler/roadmap15.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<title></title>
	<meta name="generator" content="LibreOffice 4.2.7.2 (Linux)">
	<meta name="created" content="20150108;185306555974269">
	<meta name="changed" content="20150108;190412751522454">
	<style type="text/css">
	<!--
		@page { margin: 2cm }
		p { margin-bottom: 0.25cm; line-height: 120% }
		a:link { so-language: zxx }
	-->
	</style>
<style type="text/css"></style></head>
<body lang="en-IN" dir="ltr">
<p>&nbsp;</p>
<p><b>CS 3091 Compiler Laboratory January 2015.</b></p>
<p>&nbsp;</p>
<p>SIL Compiler Design Project: Problem Specification. &nbsp;</p>
<ol>
	<li><p>1.Implement an Interpreter for a subset (without subroutine
	abstraction) of the SIL Language (Simple Integer Language SIL –
	specification available at:
	<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/sil.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">sil</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">.html</a>)&nbsp;</p>
	</li><li><p>2.Implement a two-pass compiler for SIL for SIM targer
	machine (Simple Integer Machine SIM – specification available at:
	&nbsp; <a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/sim.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">si</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">m</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">.html</a>)&nbsp;</p>
	</li><li><p>3.Implement Extensions suggested for SIL as far as you can.
	This work will carry extra credit. &nbsp;</p>
</li></ol>
<p>&nbsp;</p>
<p>Learning Objectives:</p>
<p>The project aids the student to acquire a hands on pratical
understanding of the following: &nbsp;</p>
<p>1. &nbsp;Practial realization of &nbsp;lexical and syntax analysis
using the LEX/YACC tools and learn how the syntax directed
translation scheme provided aids the construction of an intermediete
abstract syntax tree from the source program. &nbsp;</p>
<p>2. &nbsp;Practical realization of symbol table, binding of
variables, semantic analysis (including type and scope resolution),
&nbsp;machine code generation, register allocation, parameter passing
&nbsp;and run-time environment management for a very simple
programming language.</p>
<p>Evaluation Policy:</p>
<p>1. The students have to form groups with maximum three members.
&nbsp;There will be weekly evaluations and assessment of the progress
will be recorded and graded. &nbsp;</p>
<p>2. &nbsp;Final grading will be based on cumulative scores of
regular evaluations by relative grading.</p>
<p>3. &nbsp;Viva-voce/exam(s) conducted during the course of
evaluation will carry maximum 25% marks. &nbsp;</p>
<p>4. &nbsp;S grade will be provided only after a special final
evaluation among candidates who have completed all stages of the
experiment. &nbsp;</p>
<p>&nbsp;</p>
<p>Implementation Roadmap</p>
<p>The project must be carried out through various stages. This
document does not contain information about extensions of SIL. Note
that this is just a guideline for implementation and you shall and
must deviate when you feel so, with of course, a reason. 
</p>
<p>&nbsp;</p>
<p>Stage 1 Simple Calculator 
</p>
<p>Using the LEX/YACC environment implement a simple calculator. The
input is an integer arithmetic expression. Integers may be recognized
by a lexical analyzer created using LEX and passed to the YACC
generated parser. &nbsp;Write the grammar in YACC. &nbsp; Use the
syntax directed tranlation scheme in YACC to write semantic actions
to output the post fix form of the expression. The grammar is E -&gt;
NUM | E+E | E*E | (E).</p>
<p>&nbsp;</p>
<p>Stage 2: Expression Tree Evaluation.</p>
<p>Modify the attribute stack type (see usage of variable YYSTYPE in
the YACC manual) to a structure that can store an integer value. Now
modify the calculator program of Stage 1 to build an expression tree
using the syntax directed translation scheme in YACC. &nbsp;This is
the first phase (translation) where &nbsp;the source program is
converted to an intermediate form - the expression tree. &nbsp;The
second phase (execution) recursively traverses the expression tree
and evaluates it. &nbsp;</p>
<p><br>Stage 3: Straight Line program Interpreter</p>
<p>Allow integer variable names a,b,c,...z in your expression
evaluator. &nbsp;&nbsp;The token name “ID” may be used to denote
a variable. &nbsp;Consider the grammar:</p>
<p>Slist -&gt; Slist Stmt</p>
<p>Stmt -&gt; ID = E; | read(ID); | write(E);</p>
<p>E -&gt; E+E | E*E | (E) |NUM | ID</p>
<p>This allows programmes like the following (these are called
straight line programs) :</p>
<p>a=3; b=5; read(c); write(a+b+c);</p>
<p>Write an interpreter for this small language using LEX and YACC. &nbsp;</p>
<p>Introduction of the assignment statement necessitates the concept
of store. &nbsp;Each variable must be associated with a memory
location which can hold its value. &nbsp;Since the variable names are
fixed (not user defined) and there are exactly 26 variables, you can
allocate an array of 26 integers and store the values of the
variables in the array during execution. &nbsp;</p>
<p>&nbsp;</p>
<p>Stage 4: Adding Conditional and Iterative constructs. 
</p>
<p>Expand the syntax of statements to include program control
(conditional and iterative) statements. &nbsp;</p>
<p>Stmt -&gt; ID=E; | read(ID) | write(E) | If (E) then Slist endif;
| while (E) do Slist endwhile; 
</p>
<p>Allow relational operators: E -&gt; E+E | E*E | (E) | (E&lt;E) |
(E&gt;E) | E==E| NUM | ID 
</p>
<p>Use the synatax directed tranlation scheme to translate the source
program to an intermediete form called the &nbsp;abstract syntax
tree. &nbsp;Once the AST is constructed, &nbsp;the execution phase
reduces to evaluating the AST. &nbsp;&nbsp;The node structure given
below can be used for nodes in the AST (The type of the YACC variable
YYSTACK must be set to be a pointer to this tree structure):
<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/treenode.html</a></p>
<p>&nbsp;</p>
<p>Stage 5: Generating Machine Code 
</p>
<p>Go back to stage 3 and modify the straight line program to build
an abstract synatax tree (as in the previous stage) and then traverse
the tree and generate target code in Simple Integer Machine (SIM) for
the straight line program. SIM specification can be found here:
<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/sim.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/sim.html</a></p>
<p>The key issue in generating target code is register allocation.
The simplest strategy would be to allocate the smallest numbered
available register whenever a new register is needed. &nbsp;Your code
generation can be designed in a way to free the highest numbered
register after use. &nbsp; Hence a single variable for storing a
count of how many registers are in use will be sufficient to keep
track of the registers in use. &nbsp; The second issue is of binding
variables to machine locations. &nbsp;In this simple case, 26 SIM
machine locations can be pre-fixed to bind the variables. &nbsp;</p>
<p>Extend the code generator to generate code for conditional and
iterative statements introduced in Stage 4. &nbsp;Here the key issue
is generating labels for jump instructions necessary to implement the
conditional and iterative constructs. &nbsp;</p>
<p>&nbsp;</p>
<p>Stage 6: &nbsp; Interpreter with User-defined variables and arrays
</p>
<p>In this stage Identifiers can be user defined variables. &nbsp;&nbsp;All
variables in the program requires prior declaration. &nbsp;&nbsp;You
will parse the declarations and construct a symbol table for storing
variable information. &nbsp;&nbsp; The comiler decides the address
where the variable is stored and saves this address in the symbol
table (see the “binding” field in the following structure for
symbol table:
<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/symbol.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/symbol.html</a><a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/symbol.html">.</a>
)</p>
<p>The source program is translated into an AST in the first phase
and the AST is interpreted in the next phase. &nbsp;The binding field
of the symbol table must be modified (from what is given in the link)
&nbsp;to contain a pointer to the location where the variable is
stored. &nbsp;Since the size of an array is specified at the time of
its declaration, &nbsp; the binding field for an array variable may
be set to point to an array allocated to appropriate size. 
</p>
<p>Stage 7: &nbsp; Compilation with User-defined variables and arrays
</p>
<p>The main conceptual difference here from Stage 6 is that we
generate code for the target SIM machine instead of executing the AST
immedietly. &nbsp;Thus run time environment is in the target SIM
machine. &nbsp;Hence variables must be bound to storage locations in
the SIM machine. &nbsp;For each variable, fixed memory addresses in
the SIM machine may be allocated by the compiler. &nbsp;This strategy
is called Static allocation. &nbsp; The addresses of the variables
are stored in the symbol table. &nbsp; &nbsp;During the next phase
&nbsp;(code generation), &nbsp;the compiler traverses the AST and
generate target SIM code. &nbsp;&nbsp;References to variables are
translated using the information in the symbol table. &nbsp;</p>
<p>Stage 8: Adding Types</p>
<p>Modify your syntax to make the programming language syntax
compatible with the Simple Integer Language (SIL) specification
except functions (we will take up functions in the next step). SIL
specification is given here:
<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/sil.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/sil.html</a></p>
<p>You have to add logical operators to expression and boolean
constants TRUE and FALSE. 
</p>
<p>Ensure that each sub tree is type checked before connecting them
together while forming the Abstract Synatax Tree (AST) during syntax
directed translation. &nbsp; This will ensure that AST is created
only if the program has no type errors at the end of the first pass.
&nbsp;&nbsp;</p>
<p>If there is any error found, immediately report the error and stop
compilation. Once a type checked AST is formed, the program must be
free of type errors. &nbsp;Recursively traverse the tree to evaluate
(interpreter) the tree or generate SIM target code (compilation). &nbsp;
You have to implement both the interpreter and compiler for this
stage. &nbsp;You will be implementing only the compiler for the
remaining phases. &nbsp;</p>
<p>&nbsp;</p>
<p>Stage 9: Function Call Implementation -Synatax and Semantics 
</p>
<p>Now we are ready to build the full compiler for SIL. Please read
the language specification carefully before proceeding with the
implementation. You need to generate SIM target code for the whole
language. You need not do the interpreter for this stage. Here is a
structural outline for the grammar:
<a href="http://www.athena.nitc.ac.in/~kmurali/Compiler/grammar.html">http://www.athena.nitc.ac.in/~kmurali/Compiler/grammar.html</a></p>
<p>All stages of the compiler will need minor (and sometimes major)
modifications to incorporate function calls. Functions require global
declaration. &nbsp;Each function declaration shall result in creation
of a global symbol table entry for the function that contain
information such as its return type and names and types of each of
its arguments. &nbsp;</p>
<p>Each function invocation must be type checked against the
declaration. &nbsp;Note that SIL semantics requires checking function
calls for name equivalence. &nbsp;</p>
<p>&nbsp;</p>
<p>Stage 10: &nbsp;Function call Implementation-Code generation. 
</p>
<p>The SIL synatax and semantics is so designed to allow each
function to be compiled independently if the global symbol table
information is available. &nbsp; Variables local to a function will
be accessible through it local symbol table. &nbsp;The local symbol
table information in one function is not required for the generation
of code for another function. &nbsp;</p>
<p>The activities associated with a function call can be decomposed
as the following:</p>
<p>1. &nbsp;Actions done by the caller before entry: &nbsp;This
include pushing arguments into the run-time stack, allocating space
in the stack for return value and finally making the call. &nbsp;The
compiler must translate a function call into a sequence of machine
instructions to perform these actions. &nbsp;</p>
<p>2. &nbsp; Actions done by the callee upon entry: This code has to
be generated in the beginning of the callee function. &nbsp;You must
generate this code when the callee function is compiled. &nbsp;The
callee will set the base pointer to set up its activation record
after saving the base pointer of the caller in the stack. &nbsp; It
then processes its local declarations and allocate space in the stack
for local variables.</p>
<p>3. &nbsp;Actions done by the callee before return: This code
appears at the end of the calee function. It is generated during the
compilation of the callee function. &nbsp;The callee places the
return value into the appropriate location is stack, pops out space
in the stack for local variables, restores the base pointer of the
caller (so that it points to the activation record of the caller) and
then returns to the caller.</p>
<p>4. &nbsp;Actions done by the caller after return: &nbsp;This code
is generated when the caller is compiled and the code must appear
immedietely after the function call. &nbsp;The caller retrieves the
return value from the stack and adjusts the stack pointer back to the
position before the call was made. &nbsp;</p>
<p>Run time storage allocation will be necessary for this stage.
&nbsp;Functions require run time store (called activation records)
that hold local variables, call parameters and return value of the
function. &nbsp;While processing the declaration part of a function,
the compiler must assign storage to the local variables and
parameters relative to the base of the activation record of the
&nbsp;function. (The BP register of SIM is provided to store the base
address of the current activation record in memory). &nbsp;Such
relative bindings are required because a function may be invoked
several times during run time and hence may have several activation
records in the stack. &nbsp;The base of each activation record
distinguishes the particular activation record. &nbsp;All Local
variables and parameters of different invocations of the same
function will have &nbsp;the same offset relative to the respective
base. &nbsp;The SIL language enforces the stack discpline which
permits activation records to be organized in a run time stack. &nbsp;</p>
<p>Integrity Policy: &nbsp;</p>
<p>Any case of cheating including copying of code &nbsp;will
automatically qualify for an F grade. &nbsp;</p>
<p>&nbsp;</p>
<p>Wish you good luck ! 
</p>
<p>&nbsp;</p>
<p><i><b>Faculty :</b></i></p>
<p>&nbsp;</p>
<p>1. &nbsp;Vineeth Paleri : &nbsp;<a href="mailto:vpaleri@nitc.ac.in">vpaleri@nitc.ac.in</a></p>
<p>2.  Saleena N : <a href="mailto:saleena@nitc.ac.in">saleena@nitc.ac.in</a></p>
<p>3. &nbsp;K. Murali Krishnan : &nbsp;<a href="mailto:kmurali@nitc.ac.in">kmurali@nitc.ac.in</a></p>
<p>&nbsp;</p>
<p style="margin-bottom: 0cm; line-height: 100%"><br>
</p>


</body></html>