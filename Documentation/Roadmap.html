<!DOCTYPE html>
<!-- saved from url=(0038)http://silcnitc.github.io/roadmap.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Roadmap</title>
        <meta charset="UTF-8">
        <!--<link rel="stylesheet" href="css/bootstrap.min.css">-->
        <link rel="stylesheet" href="./Roadmap_files/style_new.css">

        <style media="screen">
            table.highlight{
                background-color: #F5F5F5 !important;
            }
        </style>

    <style type="text/css"></style></head>
    <body><div class="container">
        <header id="navtop">
            <a href="http://silcnitc.github.io/index.html" class="logo fleft"><img src="./Roadmap_files/logo.png" alt=""></a>
            <nav class="fright">
                <ul>
                    <li><a href="http://silcnitc.github.io/index.html">Home</a></li>
                    <li><a href="http://silcnitc.github.io/about.html">About</a></li>
        			    <li><a href="http://silcnitc.github.io/roadmap.html#">Help</a></li>
        			    <li><a href="http://silcnitc.github.io/roadmap.html#">Code</a></li>
        			    <li><a href="./Roadmap_files/Roadmap.html" class="navactive">Roadmap</a></li>
        			    <li><a href="http://silcnitc.github.io/documentation.html">Documentation</a></li>
                </ul>
            </nav>
        </header>
        <div class="Services-page main grid-wrap">
            <header class="grid col-full">
                <hr>
                <p class="fleft">ROADMAP</p>
                <br>
                <br>
                <!--<a class="button" href="">Download as PDF</a>-->
            </header>
            <aside class="grid col-one-quarter mq2-col-full">
                <menu>
                    <ul>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage0">0. Setup instructions.</a> </li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage1">1. Understanding lex &amp; yacc.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage2">2. Simple Compiler.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage3">3. Code Translation.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage4">4. Using Typetable.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage5">5. Function calls.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage6">6. Code Generation for functions.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage7">7. User defined Types</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage8">8. Code Generation for S7.</a></li>
                        <li class="sec"><a href="http://silcnitc.github.io/roadmap.html#nav-stage9">9. Buddy System Allocator.</a></li>
                    </ul>
                </menu>
            </aside>
            <section class="grid col-three-quarters mq2-col-full">
                <div class="grid-wrap">
                    <article class="grid col-full">
                        <h2>Using roadmap</h2>
                        <p>
                        	This roadmap is divided into stages. Each stage is to be done in the sequential order. Incrementally you will build ExpL Compiler according to its specification. Links are provided throughout the document for further reference. There are two kinds of links, <a href="http://silcnitc.github.io/roadmap.html#" class="imp">important links</a> and <a href="http://silcnitc.github.io/roadmap.html#">informative links</a>. You must visit the <a href="http://silcnitc.github.io/roadmap.html#" class="imp">Important links</a>  the read the immediate section to which the link points to,  in order to proceed with the roadmap. <a href="http://silcnitc.github.io/roadmap.html#">Informative links</a> may be clicked if you want more information at a particular point. However this information may not be necessary at that point. You can proceed with the roadmap without visiting these links also.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage0">
                        <h2>Stage 0 : Setup instructions</h2>
                        <p>
                            Through this course we will build a compiler for <a href="http://silcnitc.github.io/expl.html">Experimental Language</a>. Lex and Yacc are lexical and parser tools that make the job of building the compiler easy. Follow the instrcutions to install Lex and Yacc.
                        </p>
                        <h6>Install LEX</h6>
                        <p>
                            Flex is fast lexical analyser. It is used to generate programs which recognize lexical patterns in text. Flex reads the input file for descriptions of these patterns. Pairs of regular expression and C code(rules) forms the description.
                        </p>
                        <p>
                            For Ubuntu Users :
                        </p>
                        <pre>                            sudo apt-get update
                            sudo apt-get flex
                        </pre>
                        <p>
                            For Fedora Users :
                        </p>
                        <pre>                            yum install flex
                        </pre>
                        <h6>Install Yacc</h6>
                        <p>
                            Bison is a general-purpose parser generator that converts a grammar description for an LALR(1) context-free grammar into a C program to parse that grammar. Bison is upward compatible with Yacc: all properly-written Yacc grammars ought to work with Bison with no change.
                        </p>
                        <p>
                            For Ubuntu Users:
                        </p>
                        <pre>                            sudo apt-get update
                            sudo apt-get insall bison
                        </pre>
                        <p>
                            For Fedora Users
                        </p>
                        <pre>                            yum install bison
                        </pre>
                        <h6>Install XSM</h6>
                        <p>
                            XSM or Extensible String Machine is a hypotheical machine which the interface as given <a href="http://silcnitc.github.io/abi.html">here.</a> The code generated by the compiler will be in accordance with this interface.
                            <b>Steps :</b>
                        </p>
                        <p>
                            Kuddos !
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage1">
                        <h2>Stage 1 : Understanding Lex &amp; Yacc</h2>
                        <p>
                            To build the compiler with lex and yacc, you need to understand the working of these tools. In this stage, you will write some simple programs in lex and yacc and understanding what actually happens behind the curtain.
                        </p>
                        <h6>Understanding Lex</h6>
                        <ol>
                            <li>Read the sections Introduction, Structures of lex program and yyvariables <a href="http://silcnitc.github.io/lex.html" class="imp">here.</a></li>
                            <li>Create a file number.l with the content as <a href="http://silcnitc.github.io/lex.html#navyytext">yytext_example.l</a></li>
                            <li>Make necessary changes to read input from a file.</li>
                            <li>
                                Make a sample input file,<i>input</i> with the following contents.
                                <pre>                                    13
                                    45
                                    67&amp;54
                                    99-12-14
                                </pre>
                            </li>
                            <li>
                                Compiler the program using lex with the following command.
                                <pre>                                    lex number.l
                                </pre>
                                <p>
                                    You obtain a lex.yy.c file, a C program file. Compile it using GCC as follows
                                </p>
                                <pre>                                    gcc lex.yy.c
                                </pre>
                                <p>
                                    You will now obtain a.out executable file. Execute it with the sample input file.
                                </p>
                                <pre>                                    ./a.out input
                                </pre>
                                <p>
                                    After following the aboev steps correctly, you will have the following output.
                                </p>
                                <pre>                                    Found : 13

                                    Found : 45

                                    Found : 67
                                    &amp;Found : 54

                                    Found : 99
                                    -Found : 12
                                    -Found : 14
                                </pre>
                                <p>
                                    You can see that we get the text characters &amp; - and newline and space characters printed as such. This is because we haven't added any rule to ignore those characters. As a compiler writer, we should flag an error when we see a character that is not a part of language and expected.
                                </p>
                                <p>
                                    Firstly, add the following function at in lex file.
                                </p>
                                <pre>                                    yyerror(char const *s)
                                    {
                                        &nbsp;&nbsp;printf("yyerror %s",s);
                                    }
                                </pre>
                                <p>
                                     So add the rule which flags an error whenever an unexpected charater appears in the language we are parsing. Dont forget to add the rule to ignore whitespaces and new line characters. Note : this rule is added at the end in rules section.
                                </p>
                                <pre>                                    [ \n\t] {}
                                    .  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ yyerror("Invalid charater "); printf("%s\n",yytext); exit(1); }
                                </pre>
                                <p>
                                    Now again compile the program with lex and gcc commands as given above and execute. You will see the following output.
                                </p>
                                <pre>                                    Found : 13
                                    Found : 45
                                    Found : 67
                                    yyerror : Invalid charater &amp;
                                </pre>
                            </li>
                            <li>Complete the remaining sections and understand the working of <a href="http://silcnitc.github.io/lex.html#navfunctions">lex</a> tool properly. Do the <a href="http://silcnitc.github.io/lex.html#navexercise">exercises</a> at the end of the lex document.</li>
                        </ol>
                        <h6>Assignment</h6>
                        <p>
                            Find the regular expressions for strings. Write a lex program to read strings and print them.
                        </p>
                        <h6>Understanding Yacc</h6>
                        <p>
                            Through this section, we will write an infix to postfix yacc program by understanding the basics while building it.
                        </p>
                        <ol>
                            <li>Go through the sections <a href="http://silcnitc.github.io/yacc.html#navintro">Introduction</a> and <a href="http://silcnitc.github.io/yacc.html#navstructure">Structure of Yacc Programs</a> in the yacc <a href="http://silcnitc.github.io/yacc.html">document.</a></li>
                            <li>Create a infix_to_postfix.y file with content as in <a href="http://silcnitc.github.io/yacc.html#navexy0d">intopost.y</a></li>
                            <li>Add necessary statements in the program to support operations '/' and '-' .</li>
                            <li>Run the commands below the program to check the correctness of the program.</li>
                            <li>Understand the shift reduce parsing <a href="http://silcnitc.github.io/yacc.html#navshiftreduce">here</a>.</li>
                            <li>Understand the working of the infix_to_postfix program from the section <a href="http://silcnitc.github.io/yacc.html#navinfixtopostfix">here.</a> The use of %left %right can be understood by reading <a href="http://silcnitc.github.io/yacc.html#navconflict">this.</a></li>
                            <li>
                                <p>
                                    When there are lots of grammar rules written in the program, it becomes difficult to figure out the rules which cause the conflict.
                                </p>
                                <p>
                                    To solve such issues, compile your yacc program with the following command
                                </p>
                                <pre>                                    yacc -v infix_to_postfix.y
                                </pre>
                                <p>
                                    A y.output file will be obtained. Examine the starting lines of lines which gives the state that causes the conflict. Go the state that causes the conflicts and identify the grmmmar rules that lead to these conflicts.
                                </p>
                                <p>
                                    To understand how to work with conflicts, in your program remove the %left and other associativity lines and compile it using the above command and examine your y.output file.
                                </p>
                            </li>
                            <li>Go through the section <a href="http://silcnitc.github.io/yacc.html#navpassingvalues">here.</a> Make necessary changes in your program also to print the values.</li>
                            <li>Complete the <a href="http://silcnitc.github.io/yacc.html#navusingthelexicalanalyzer">exercises</a>.</li>
                        </ol>
                        <h6>Assignment</h6>
                        <ol>
                            <li>Modify the infix_to_postfix.y such that it gives the value of the complete expression as output. (Hint : use $$ to assign value to head of a rule).</li>
                            <li>Now write a program to concatenate two strings using the operator '+'.</li>
                        </ol>
                        <h6>Understanding lex with yacc.</h6>
                        <p>
                            Go through the complete documentation <a href="http://silcnitc.github.io/ywl.html">here.</a> Make sure you practice the following programs given in the documentation while going through the tutorial.
                            </p><li>Infix to postfix conversion.</li>
                            <li>Read and write pairs.</li>
                            <li><b>Simple Calculator.</b></li>
                        <p></p>
                        <p>
                            You will also see how to build an expression tree and evaluate an expression. It is very necessary to understand these basic concepts of expression tree before going further. Build a calculator using expression trees yourself after going through the tutorial.
                        </p>
                    </article>
                    <article class="grid col-full" id="nav-stage2">
                        <h2>Stage 2 : Simple Compiler</h2>
                        <p>
                            From here on, we will build the compiler in stages. In this stage, we will build a simple single line interpreter. We will all single letter varaiables a | b | .... | z of integer type. We will have read and write functions, assignment operator, addition and multiplication operations, allowing paranthesis in the expression.
                        </p>
                        <p>
                            Follow the steps below.
                            </p><ol>
                                <li> Create an expl.l file for lexical analysis and expl.y for parsing.</li>
                                <li>
                                    <p>
                                        In expl.y, set the stack type with a union of character and integer.
                                    </p>
                                    <pre>                                        %union{
                                            &nbsp;&nbsp;int integer;
                                            &nbsp;&nbsp;char character;
                                        };
                                    </pre>

                                </li>
                                <li>
                                    <p>
                                        We have numbers, single letter variable, + , * , = , read , write for which we will have tokens NUM, ID , PLUS , MUL , ASGN , READ , WRITE repectively . For '(' , ')' , ';' we will pass them as yytext itself.
                                    </p>
                                    <p>
                                        So we have the following rules in expl.l (Note : Add the necessary declarations in the declarations section, and yywrap() in auxiliary functions section).
                                        </p><pre>                                            [a-z] &nbsp;&nbsp;&nbsp;{ yylval.character = yytext[0]; return ID;}
                                            [0-9]+ &nbsp;&nbsp;{ yylvavl.integer = atoi(yytext); return NUM;}
                                            "read"  &nbsp;&nbsp;{ return READ;}
                                            [=]    &nbsp;&nbsp;&nbsp;&nbsp; { return ASGN;}
                                        </pre>
                                    <p></p>
                                    <p>
                                        Add the rules for write, plus, minus , parathensis and semicolon. Make sure you write rules to ignore the whitespaces.
                                    </p>
                                </li>
                                <li>
                                    Next step is to add the grammar rules in yacc. Whenever a grammar rule is added, make sure you add the tokens and type of non-terminals in the rule in auxiliary declaration section.
                                </li>
                                <li>Add the rule for expr as in the expression program in previous stage.</li>
                                <li>
                                    Every ID has a value an therefore it is an expression.Add the following grammar rule also :
                                    <pre>                                        expr : ID
                                    </pre>
                                </li>
                                <li>
                                    <p>
                                        As we have only singled letter variables of integer type, we will have only 26 variables.So to store the values of the variables that we obtain at the run time of the program, we will use
                                    </p>
                                    <pre>                                        int *var[26];
                                    </pre>
                                    <p>
                                        if variable is unassigned, print an error, else assign the value of the variable ID $1 to the head of rule expr $$. So you will have the actions as follows:
                                    </p>
                                    <br>
                                    <script src="./Roadmap_files/3347c65a583af61f95e7.js"></script><link rel="stylesheet" href="./Roadmap_files/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4602b825bd9.css"><div id="gist29559393" class="gist">
    <div class="gist-file">
      <div class="gist-data">
        <div class="js-gist-file-update-container js-task-list-container file-box">
  <div id="file-expr_action-y" class="file">
    

  <div class="blob-wrapper data type-yacc">
      <table class="highlight tab-size js-file-line-container" data-tab-size="8">
      <tbody><tr>
        <td id="file-expr_action-y-L1" class="blob-num js-line-number" data-line-number="1"></td>
        <td id="file-expr_action-y-LC1" class="blob-code blob-code-inner js-file-line">expr : ID {</td>
      </tr>
      <tr>
        <td id="file-expr_action-y-L2" class="blob-num js-line-number" data-line-number="2"></td>
        <td id="file-expr_action-y-LC2" class="blob-code blob-code-inner js-file-line">            if( var[$1 - 'a'] == NULL)</td>
      </tr>
      <tr>
        <td id="file-expr_action-y-L3" class="blob-num js-line-number" data-line-number="3"></td>
        <td id="file-expr_action-y-LC3" class="blob-code blob-code-inner js-file-line">                printf("unassinged varaiable");</td>
      </tr>
      <tr>
        <td id="file-expr_action-y-L4" class="blob-num js-line-number" data-line-number="4"></td>
        <td id="file-expr_action-y-LC4" class="blob-code blob-code-inner js-file-line">            else</td>
      </tr>
      <tr>
        <td id="file-expr_action-y-L5" class="blob-num js-line-number" data-line-number="5"></td>
        <td id="file-expr_action-y-LC5" class="blob-code blob-code-inner js-file-line">                $$ = *var[$1 - 'a'];</td>
      </tr>
      <tr>
        <td id="file-expr_action-y-L6" class="blob-num js-line-number" data-line-number="6"></td>
        <td id="file-expr_action-y-LC6" class="blob-code blob-code-inner js-file-line">          }</td>
      </tr>
</tbody></table>

  </div>

  </div>
  
</div>

      </div>
      <div class="gist-meta">
        <a href="https://gist.github.com/vishnupriyam/3347c65a583af61f95e7/raw/52e9be3a2963a2c4467d68b7485b73ec1709d12e/expr_action.y" style="float:right">view raw</a>
        <a href="https://gist.github.com/vishnupriyam/3347c65a583af61f95e7#file-expr_action-y">expr_action.y</a>
        hosted with ❤ by <a href="https://github.com/">GitHub</a>
      </div>
    </div>
</div>

                                    <br>
                                    <p>
                                        Don't forget to add type integer for the non-terminal expr.
                                    </p>
                                </li>
                                <li>
                                    <p>
                                        Assignment, read and write are statements of the program.
                                    </p>
                                    <pre>                                        stmt : ID ASGN expr ';'
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| READ '(' ID ')' ';'
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| WRITE '(' expr ')' ';'
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
                                    </pre>
                                </li>
                                <li>Now we will add actions for read statement.
                                    <ul>
                                        <li>If the varaiable was unallocated before, do malloc.</li>
                                        <li>Read value for the variable from standard input</li>
                                    </ul>
                                    <br>
                                    <script src="./Roadmap_files/905e77cff04f9bf4f5cd.js"></script><link rel="stylesheet" href="./Roadmap_files/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4602b825bd9.css"><div id="gist29560097" class="gist">
    <div class="gist-file">
      <div class="gist-data">
        <div class="js-gist-file-update-container js-task-list-container file-box">
  <div id="file-variable-y" class="file">
    

  <div class="blob-wrapper data type-yacc">
      <table class="highlight tab-size js-file-line-container" data-tab-size="8">
      <tbody><tr>
        <td id="file-variable-y-L1" class="blob-num js-line-number" data-line-number="1"></td>
        <td id="file-variable-y-LC1" class="blob-code blob-code-inner js-file-line">if(var[$3-'a'] == NULL){</td>
      </tr>
      <tr>
        <td id="file-variable-y-L2" class="blob-num js-line-number" data-line-number="2"></td>
        <td id="file-variable-y-LC2" class="blob-code blob-code-inner js-file-line">    var[$3 - 'a'] = malloc(sizeof(int));</td>
      </tr>
      <tr>
        <td id="file-variable-y-L3" class="blob-num js-line-number" data-line-number="3"></td>
        <td id="file-variable-y-LC3" class="blob-code blob-code-inner js-file-line">}</td>
      </tr>
      <tr>
        <td id="file-variable-y-L4" class="blob-num js-line-number" data-line-number="4"></td>
        <td id="file-variable-y-LC4" class="blob-code blob-code-inner js-file-line">scanf("%d",var[$3-'a']);</td>
      </tr>
</tbody></table>

  </div>

  </div>
  
</div>

      </div>
      <div class="gist-meta">
        <a href="https://gist.github.com/vishnupriyam/905e77cff04f9bf4f5cd/raw/18fb193f18addca121475ad2c5dd5e5a12f5bc04/variable.y" style="float:right">view raw</a>
        <a href="https://gist.github.com/vishnupriyam/905e77cff04f9bf4f5cd#file-variable-y">variable.y</a>
        hosted with ❤ by <a href="https://github.com/">GitHub</a>
      </div>
    </div>
</div>

                                    <br>
                                    <p>
                                        Add actions for assignment and write statements similarly.
                                    </p>
                                </li>
                                <li>A program has one or more than one statements. Single line program consists of statement block and ends with a new line.So we will have the following rules.
                                    <pre>                                        Program : slist NEWLINE
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
                                        slist   : slist stmt
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| stmt
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
                                    </pre>
                                </li>
                                <li>Add the necessary main function in yacc file.</li>
                                <li>Run the commands
                                    <pre>                                        yacc -y -d expl.y
                                        lex expl.l
                                        gcc y.tab.c lex.yy.c
                                        ./a.out
                                    </pre>
                                </li>
                                <li>Give the following input:
                                    <pre>                                        read(a); read(h); c=10; write(a); a = a+h*c; write(a);
                                    </pre>
                                </li>
                                <li>Check if your program runs properly.</li>
                            </ol>
                        <p></p>
                    </article>
                    <article class="grid col-full" id="nav-stage3">
                        <h2>Stage 3 : Code Translation</h2>
                    </article>
                    <article class="grid col-full" id="nav-stage4">
                        <h2>Stage 4 : Using Typetable</h2>
                        <h6>Using Type Table and Symbol Table</h6>
                        <p>
                            In this stage, we will modify the stage 2 interpreter.
                            </p><ul>
                                <li>Allow variables of the form given <a href="http://silcnitc.github.io/expl.html#expl-identifiers" class="imp">here.</a></li>
                                <li>Add data types : int and str.</li>
                                <li>Add conditional and iterative statements, logical expressions, break and continue statements as given <a href="http://silcnitc.github.io/expl.html#nav-stmts-and-exprs" class="imp">here.</a></li>
                            </ul>
                            This stage requires the understanding of <a href="http://silcnitc.github.io/Data_Structures.html">data structures</a> : <a href="http://silcnitc.github.io/Data_Structures.html#nav-typetable" class="imp">type table</a>, <a href="http://silcnitc.github.io/Data_Structures.html#nav-global-symbol-table" class="imp">symbol table</a> and <a href="http://silcnitc.github.io/Data_Structures.html#nav-abstract-syntax-tree" class="imp">abstract syntax tree</a>.
                        <p></p>
                        <p>
                            Follow the below steps to make changes for variables to be user-defined.
                            </p><ol>
                                <li>Modify the regular expression for ID in your lex file to satify the form given in the <a href="http://silcnitc.github.io/expl.html#expl-identifiers">expl documentation.</a>, i.e, they can be user-defined variables.</li>
                                <li>
                                    <p>
                                        Create a new file symboltable.h, add the structure of <a href="http://silcnitc.github.io/Data_Structures.html#gist28650622" class="imp">Symbol Table.</a>We will use this symbol table to store the information regarding the variable. As of now we don't require the arglist, fbinding fields of the Symbol Table.
                                    <br>
                                        <b>Note</b> : Whenever we add data structures to our program, we add its structures, global declarations and associated function declarations in the .h file and we implement the associated functions in the .c file. This will help you keep the code neat and easy to understand.
                                    </p>
                                </li>
                                <li>In compiler, we store the memory address allocated to the variable, while in the interpreter, we will store the value of variable in the binding field. Therefore, change the type of binding field to union Constant which has the following structure
                                    <pre>                                        union Constant{
                                            &nbsp;&nbsp;int intval;
                                            &nbsp;&nbsp;char* strval;
                                        };
                                    </pre>
                                We use a union here because <a href="http://silcnitc.github.io/expl.html#nav-data-types">expl</a> supports two primitive types int and str.
                                <p>
                                    Declare a global variable GSymbolHead which will act as head pointer to the global symbol table.
                                </p>
                                <p>
                                    You may go through the illustration under the <a href="http://silcnitc.github.io/Data_Strcutures.html#nav-global-symbol-table">symbol table section</a> for better understanding.
                                </p>
                                </li>
                                <li>Go though the section <a href="http://silcnitc.github.io/Data_Structures.html#nav-typetable" class="imp"> Type Table</a>. Take down the structure to symboltable.h file. Go through the illustrations also. Declare a global variable TypeTableHead which will act as head pointer of type table.</li>
                                <li>Now implement the functions TTableCreate(), TLookup(), TInstall() under the associated methods for typetable in symboltable.c file.</li>
                                <li>Implement functions GInstall(), Glookup(), AddGtype() and GAppend() associated with symbol table in symboltable.c file</li>
                                <li>Include the symboltable.h and symboltable.c file in your expl.y file.</li>
                            </ol>
                        <p></p>
                        <p>
                            Follow the steps below to add grammar rules to support conditional and iterative statements, logical expressions, break and continue statements and declarations as allowed by <a href="http://silcnitc.github.io/expl.html#nav-stmts-and-exprs">expl.</a>
                        </p>
                        <ol>
                            <li>
                                To support logical expressions add the following grammar:
                                <pre>                                    expr : expr GT expr
                                         ;
                                </pre>
                                GT is the token representing &gt; .
                                Similarly add rules for operators &lt;,&gt;=,&lt;=,== and !=.
                            </li>
                            <li>
                                To support conditional statement if, following rule is to be added.
                                <pre>                                    stmt : IF '(' expr ')' THEN slist ELSE slist endif ';'
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| IF '(' expr ')' THEN slist endif ';'
                                </pre>
                                IF, ELSE, THEN are tokens. Add the necessary rules in lex to support these tokens.
                            </li>
                            <li>
                                Similarly, rule for while is :
                                <pre>                                    stmt : WHILE '(' expr ')' DO slist ENDWHILE ';'
                                         ;
                                </pre>
                            </li>
                            <li>
                                Now add necessary rules and declarations for break and continue.
                            </li>
                            <li>
                                To support declarations in the program, add
                                <pre>                                    Program : GdeclBlock slist END
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;

                                    GdeclBlock : DECL GDecList ENDDECL
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;

                                    GDecList : GDecList GDecL
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;

                                    GDecL : INT idlist ';'
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| STR idlist ';'
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;


                                    idlist : idlist ',' ID
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ID
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
                                </pre>
                            </li>
                        </ol>
                        <h6>Using Abstract Syntax Tree</h6>
                        <p>
                            In this stage you will use the synatax directed tranlation scheme to translate the source program to an intermediete form called the  abstract syntax tree. The abstract syntax tree structure is available <a href="http://silcnitc.github.io/Data_Structures.html#nav-abstract-syntax-tree" class="imp">here.</a> Take down the structure and declare the two associated functions in a new file abstracttree.h . We will implement them later. (Take down the structure of valstruct also and define its possible types).
                        </p>
                        <p>
                            Now we will add actions to the yacc rules. You may remove all the actions that we used in stage 2 as in this stage the actions will be in accordance with the abstact syntax tree structure. As the parsing is done, we will build a abstract syntax tree in accordance. This abstract syntax tree is evaluated later on to interpret the program.
                        </p>
                        <p>
                            Follow the below steps :
                        </p>
                        <ol>
                            <li>
                                Whenever we pass an ID from the lexical analyser as an abstract syntax tree node, that means the stack type can be a ASTNode also. So we will modify the stack type by adding a new field <i>struct ASTNode *nptr</i> in %union{}; in yacc declarations section. Now add the statement
                                <pre>                                    yylval.nptr = TreeCreate(TLookup("void"),NODETYPE_ID,yytext,(Constant){},NULL,NULL,NULL,NULL);
                                </pre>
                                in the actions for lex rule that recognises an ID. Change the type of ID in yacc declarations section to type nptr and define NODETYPE_ID in abstracttree.h file.
                                <pre>                                    #define NODETYPE_ID 1
                                </pre>
                            </li>
                            <li>Firstly, we will add actions such that the symbol table is created properly.
                                <ul>
                                    <li>
                                        For rules, idlist : idlist ',' ID | ID , create a gsymbol table object for ID. ie,
                                        <pre>                                            idlist : ID { $$ = GInstall($1-&gt;name,NULL,1,NULL); }
                                        </pre>
                                        Here we don't have the type of the variable ,so pass it as NULL. We will set this at a later time. The size is 1 for all primitive types. The size is greater than 1 for array variables only.
                                        For the rule, <i>idlist : idlist ',' ID</i> the next field is $1. We have to create a list of IDs so that the IDs are carried up till the rule like <i>decl : INT idlist ';'</i> where you can set the type of the variables.
                                    </li>
                                    <li>
                                        Next, at the rule GDecL : INT idlist ';' add the type for all variables in the idlist as 'int' using the function AddGType() and then append the entries to the Symbol table using the function GAppend(). Add actions for string declarations also.
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p>
                                    Before going further, look at your grammar, and list down the nodetypes that we would be using in our compiler.
                                </p>
                                <p>
                                    For example, consider the grammar
                                    </p><pre>                                        expr : expr PLUS expr
                                    </pre>
                                    Here we require NODETYPE_PLUS.
                                    <pre>                                        stmt : IF '(' expr ')' THEN slist ELSE slist ENDIF ';'
                                    </pre>
                                    Here as you see we will require NODETYPE_IF with left branch as tree for expr, middle branch as NODETYPE_SLIST (whose code is executed if code for left branch returns a true value at run time) and right branch is of NODETYPE_SLIST again(whose code is exeucted if the code for left branch returns false at run time).
                                <p></p>
                            </li>
                            <li>For numbers that are passed from lex, send them as a NODETYPE_LEAF as follows:
                                <pre>                                    yylval.nptr = TreeCreate(TLookUp("int"),NODETYPE_LEAF,NULL,(Constant){number},NULL,NULL,NULL,NULL);
                                </pre>
                                and for strings, add the rule and pass them as
                                <script src="./Roadmap_files/abf6aa595c1800b9510c.js"></script><link rel="stylesheet" href="./Roadmap_files/embed-2cd369fa1c0830bd3aa06c21d4f14a13e060d2d31bbaae740f4af4602b825bd9.css"><div id="gist29560292" class="gist">
    <div class="gist-file">
      <div class="gist-data">
        <div class="js-gist-file-update-container js-task-list-container file-box">
  <div id="file-string_lex_action-y" class="file">
    

  <div class="blob-wrapper data type-yacc">
      <table class="highlight tab-size js-file-line-container" data-tab-size="8">
      <tbody><tr>
        <td id="file-string_lex_action-y-L1" class="blob-num js-line-number" data-line-number="1"></td>
        <td id="file-string_lex_action-y-LC1" class="blob-code blob-code-inner js-file-line">\"(\\.|[^\\"])*\"  {</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L2" class="blob-num js-line-number" data-line-number="2"></td>
        <td id="file-string_lex_action-y-LC2" class="blob-code blob-code-inner js-file-line">			Constant val;</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L3" class="blob-num js-line-number" data-line-number="3"></td>
        <td id="file-string_lex_action-y-LC3" class="blob-code blob-code-inner js-file-line">			val.strval = (char *)malloc(sizeof(yytext) - 2);</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L4" class="blob-num js-line-number" data-line-number="4"></td>
        <td id="file-string_lex_action-y-LC4" class="blob-code blob-code-inner js-file-line">			strncpy(val.strval, yytext + 1, strlen(yytext) - 2);</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L5" class="blob-num js-line-number" data-line-number="5"></td>
        <td id="file-string_lex_action-y-LC5" class="blob-code blob-code-inner js-file-line">			(val.strval)[strlen(yytext)-2] = '\0';</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L6" class="blob-num js-line-number" data-line-number="6"></td>
        <td id="file-string_lex_action-y-LC6" class="blob-code blob-code-inner js-file-line">			yylval.nptr = TreeCreate(TLookUp("str"),NODETYPE_LEAF,NULL, val,NULL,NULL,NULL,NULL);</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L7" class="blob-num js-line-number" data-line-number="7"></td>
        <td id="file-string_lex_action-y-LC7" class="blob-code blob-code-inner js-file-line">			return STRCONST;</td>
      </tr>
      <tr>
        <td id="file-string_lex_action-y-L8" class="blob-num js-line-number" data-line-number="8"></td>
        <td id="file-string_lex_action-y-LC8" class="blob-code blob-code-inner js-file-line">		    }</td>
      </tr>
</tbody></table>

  </div>

  </div>
  
</div>

      </div>
         </div>
</div>

                                <!--
                                <pre>
                                    \"(\\.|[^\\"])*\"
                                        {
                							Constant val;
                							val.strval = (char *)malloc(sizeof(yytext) - 2);
                							strncpy(val.strval, yytext + 1, strlen(yytext) - 2);
                							(val.strval)[strlen(yytext)-2] = '\0';
                							yylval.nptr = TreeCreate(TLookUp("str"),NODETYPE_LEAF,NULL, val,NULL,NULL,NULL,NULL);
                							return STRCONST;
                						}
                                </pre>
                                -->
                            </li>
                            <li>
                                Next we will add rules in our yacc file. Lets consider the rule <i>expr : ID</i>, here we already have ID as a node. So add the rule
                                <pre>                                    $$ = $1.
                                </pre>
                                The case of expr : NUM | STRCONST is similar.
                            </li>
                            <li>
                                Consider the rule <i>expr : expr PLUS expr</i>, we already have $1 and $3 as two ASTNodes.So all you require to do is to create a tree node with NODETYPE_PLUS with type 'int' with branches as $1 and $3.
                                <pre>                                    $$ = TreeCreate(TLookUp("int"), NODETYPE_PLUS , NULL, (Constant){}, NULL, $1, $3, NULL);
                                </pre>
                                Complete the actions for -,*,/ rules. Similar is the case of logical operators &gt;,&lt;,&gt;=,&lt;=,==,!= but the type of tree node would be different. Add the actions for grammar rules with these operations also.
                            </li>
                            <li>Add action for the rule expr : '(' expr ')' which is pretty simple.</li><a href="http://silcnitc.github.io/t"></a>
                            <li>
                                Consider the rule for conditional statement , if
                                <pre>                                    stmt : IF '(' expr ')' THEN slist ELSE slist endif ';' { $$ = TreeCreate(TLookup("void"), NOETYPE_IF,NULL,(Constant){},$3,$6,$8); }
                                </pre>
                             </li>
                            <li>Similarly create a tree node for assignment statement, iterative statements, read and write with nodetypes NODETYPE_ASGN, NODETYPE_WHILE, NODETYPE_READ AND NODETYPE_WRITE respectively.</li>
                            <li>
                                Now we have a statments in our program of which each is a tree node. Connect the statements as follows:
                                <pre>                                    slist : slist stmt {$$ = TreeCreate(TLookUp("void"), NODETYPE_SLIST , NULL, (Constant){}, NULL, $1, $2, NULL);}
                                </pre>
                            </li>
                            <li>Finally, we will obtain a tree at the topmost rule <i>Program : GdeclBlock slist END</i> of which we will evaluate the tree at $2 with the help of Symbol Table formed by GdeclBlock section. So,
                            <pre>                                Program : GdeclBlock slist EOF { evaluate($2); }
                            </pre>
                                Note : EOF is the End Of the File token (lex recognises end of file with the regular expression &lt;<eof>&gt; .)
                            </eof></li>
                        </ol>
                        <p>
                            Following is the list of nodetypes that are used in this stage:
                            </p><ul>
                                <li>NODETYPE_LEAF</li>
                                <li>NODETYPE_ID</li>
                                <li>NODETYPE_PLUS</li>
                                <li>NODETYPE_MINUS</li>
                                <li>NODETYPE_MUL</li>
                                <li>NODETYPE_DIV</li>
                                <li>NODETYPE_GT</li>
                                <li>NODETYPE_LT</li>
                                <li>NODETYPE_GE</li>
                                <li>NODETYPE_LE</li>
                                <li>NODETYPE_EQ</li>
                                <li>NODETYPE_NE</li>
                                <li>NODETYPE_IF</li>
                                <li>NODETYPE_WHILE</li>
                                <li>NODETYPE_READ</li>
                                <li>NODETYPE_WRITE</li>
                                <li>NODETYPE_SLIST</li>
                                <li>NODETYPE_ASGN</li>
                            </ul>
                        <p></p>
                        <p>
                            The next step is to implement TreeCreate() function.
                        </p>
                        <ol>
                            <li>
                                The first step is to do type checking for each nodetype. For example, consider the NODETYPE_PLUS. We can perform the addition operation only on two integers. So, both the subtrees of the nodetype_plus must be of type int. So the type check is : (in switch case for nodetype)
                                <pre>                                    case NODETYPE_PLUS : if(strcmp(ptr1-&gt;type-&gt;name,"int") != 0 || strcmp(ptr2-&gt;type-&gt;name,"int") != 0 ){
                                                            yyerror("TreeCreate : Operands for plus are not of integer type");
                                                            exit(1);
                                                         }
                                </pre>
                                Do type checks for NODETYPE_MINUS, NODETYPE_DIV, NODETYPE_MUL, NODETYPE_GT, NODETYPE_LT, NODETYPE_GE, and NODETYPE_LE.
                            </li>
                            <li> For NODETYPE_EQ and NODETYPE_NE both branches must be of type "int" or both must be of type "boolean".</li>
                            <li> For NODETYPE_READ the Id must be of type "int" or "str" . You will understand the significance of this type check when we introduce user defined variables. Similar is the case of NODETYPE_WRITE</li>
                            <li> For NODETYPE_IF, the first conditional branch must be of type boolean. NODETYPE_WHILE also has the same type check.</li>
                            <li>For NODETYPE_ASGN, the types of both the branches must be same.</li>
                            <li>Set the Gentry of the ASTNode of NODETYPE_ID. Gentry points to the Symbol Table entry for variables. If a Symbol Table entry for the variable does not exist, an appropriate error should be reported. Set the type of ASTNode of a NODETYPE_ID with the type of the variable as in its symbol table entry.</li>
                            <li>After the type checks,set the fields of the newly created ASTNode according to the arguements passed to the function and above steps and return it. </li>
                        </ol>
                        <p>
                            Follow the steps below and implement the function interpret().
                        </p>
                        <ol>
                            <li>
                                Firstly, declare an array of valstructs of size 14
                                <pre>                                    struct valstruct values[14];
                                </pre>
                            </li>
                            <li>
                                Declare a variable value_count. You will use the array as a stack here. Implement two functions get_valstruct() and free_valstruct().
                                <ul>
                                    <li>int get_valstruct() : Returns the topmost valstruct that is free and increments the value_count.</li>
                                    <li>void free_valstruct() : Frees the topmost valstruct object and decrements the value_count.</li>
                                    <li>value_count is intially set to -1.</li>
                                </ul>
                            </li>
                            <li>Following is the basic structure of the evaluate function.


                            </li>
                        </ol>
                        <p>
                            Call TTableCreate() function from the main function in yacc to initialise the typetable.
                        </p>
                    </article>
                </div>
            </section>
        </div>
    </div>

</body></html>